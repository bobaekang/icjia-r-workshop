<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />


<meta name="author" content="Bobae Kang" />

<meta name="date" content="2018-03-28" />

<title>R Workshop: Module 3 (2)</title>

<script src="notes_files/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="notes_files/bootstrap-3.3.5/css/bootstrap.min.css" rel="stylesheet" />
<script src="notes_files/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="notes_files/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="notes_files/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="notes_files/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="notes_files/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="notes_files/tocify-1.9.1/jquery.tocify.js"></script>
<script src="notes_files/navigation-1.1/tabsets.js"></script>
<link href="notes_files/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="notes_files/highlightjs-9.12.0/highlight.js"></script>

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>

<link rel="stylesheet" href="../css/style.css" type="text/css" />

</head>

<body>

<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
  height: auto;
}
.tabbed-pane {
  padding-top: 12px;
}
button.code-folding-btn:focus {
  outline: none;
}
</style>



<div class="container-fluid main-container">

<!-- tabsets -->
<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});
</script>

<!-- code folding -->




<script>
$(document).ready(function ()  {

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_').toLowerCase();
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}


.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
  padding-left: 25px;
  text-indent: 0;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>

<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row-fluid">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="fluid-row" id="header">



<h1 class="title toc-ignore">R Workshop: Module 3 (2)</h1>
<h4 class="author"><em>Bobae Kang</em></h4>
<h4 class="date"><em>March 28, 2018</em></h4>

</div>


<!-- fontawesome CDN -->
<p><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"></p>
<!-- logo -->
<div class="logo">
<p><a href="http://www.icjia.state.il.us/"><img src="../images/icjia.png" alt="ICJIA logo"></img></a></p>
</div>
<p>This page contains the notes for <strong>the second part of R Workshop Module 3: Data Analysis with R</strong>, which is part of the R Workshop series prepared by ICJIA Research Analyst <a href="http://www.icjia.state.il.us/biographies/bobae-kang">Bobae Kang</a> to enable and encourage ICJIA researchers to take advantage of R, a statistical programming language that is one of the most powerful modern research tools.</p>
<div id="links" class="section level3">
<h3>Links</h3>
<p>Click <a href="../index.html"><strong>here</strong></a> to go to the workshop <strong>home page</strong>.</p>
<p>Click <a href="../modules.html"><strong>here</strong></a> to go to the workshop <strong>Modules page</strong>.</p>
<p>Click <a href="../slides/module3_slides2.html"><strong>here</strong></a> to view the accompanying <strong>slides for Module 3, Part 2</strong>.</p>
<p>Navigate to the other workshop materials:</p>
<button class="btn" data-toggle="collapse" data-target="#collapse-navigate" aria-expanded="false" aria-controls="collapse-navigate">
<strong>SEE MORE</strong>
</button>
<div id="collapse-navigate" class="collapse mt-1">
<div style="padding:20px;">
<ul>
<li><strong>Module 1: Introduction to R</strong> (<a href="../slides/module1_slides.html"><strong>slides</strong></a>, <a href="module1_notes.html"><strong>note</strong></a>)</li>
<li><strong>Module 2: R basics</strong>
<ul>
<li>Part 1 (<a href="../slides/module2_slides1.html"><strong>slides</strong></a>, <a href="module2_notes1.html"><strong>note</strong></a>)</li>
<li>Part 2 (<a href="../slides/module2_slides2.html"><strong>slides</strong></a>, <a href="module2_notes2.html"><strong>note</strong></a>)</li>
</ul></li>
<li><strong>Module 3: Data analysis with R</strong>
<ul>
<li>Part 1 (<a href="../slides/module3_slides1.html"><strong>slides</strong></a>, <a href="module3_notes1.html"><strong>note</strong></a>)</li>
</ul></li>
<li><strong>Module 4: Data visualization with R</strong>
<ul>
<li>Part 1 (<a href="../slides/module4_slides1.html"><strong>slides</strong></a>, <a href="module4_notes1.html"><strong>note</strong></a>)</li>
<li>Part 2 (<a href="../slides/module4_slides2.html"><strong>slides</strong></a>, <a href="module4_notes2.html"><strong>note</strong></a>)</li>
</ul></li>
<li><strong>Module 5: Statistical modeling with R</strong>
<ul>
<li>Part 1 (<a href="../slides/module5_slides1.html"><strong>slides</strong></a>, <a href="module5_notes1.html"><strong>note</strong></a>)</li>
<li>Part 2 (<a href="../slides/module5_slides2.html"><strong>slides</strong></a>, <a href="module5_notes2.html"><strong>note</strong></a>)</li>
</ul></li>
<li><strong>Module 6: “To Infinity and Beyond”</strong>
<ul>
<li>Part 1 (<a href="../slides/module6_slides1.html"><strong>slides</strong></a>, <a href="module6_notes1.html"><strong>note</strong></a>)</li>
<li>Part 2 (<a href="../slides/module6_slides2.html"><strong>slides</strong></a>, <a href="module6_notes2.html"><strong>note</strong></a>)</li>
</ul></li>
</ul>
</div>
</div>
<hr />
</div>
<div id="data-analysis-with-r-2-more-on-data-analysis" class="section level1">
<h1>Data Analysis with R (2): More on data analysis</h1>
<img src="../images/more_data_analysis.png" width="35%" style="box-shadow: none; display: block; margin: auto;" />
<div style="font-size:0.5em; text-align:center; color: #777;">
<p>Source: <a href="https://cdn4.iconfinder.com/data/icons/basic-dashboard-1/512/Basic_Dashboard_UI_fix_option_machine_tools-512.png">Iconfinder.com</a></p>
</div>
<p>The second part of Module 3 introduces more <code>tidyverse</code> tools for working with data. Specifically, this part covers (1) working with string data using <code>stringr</code>, (2) working with date and date-time data using <code>lubridate</code>, and (3) importing and exporting data using various packages.</p>
<hr />
</div>
<div id="working-with-strings" class="section level1">
<h1>Working with Strings</h1>
<img src="../images/font_case.png" width="25%" style="box-shadow: none; display: block; margin: auto;" />
<div style="font-size:0.5em; text-align:center; color: #777;">
<p>Source: <a href="https://www.rstudio.com/">RStudio</a></p>
</div>
<p>In computer programming, a “string” often refers to a string of characters. Manipulating strings is an important skill for data analysis.</p>
<div id="stringr-from-tidyverse" class="section level2">
<h2><code>stringr</code> from tidyverse</h2>
<img src="../images/stringr.png" width="25%" style="box-shadow: none; display: block; margin: auto;" />
<div style="font-size:0.5em; text-align:center; color: #777;">
<p>Source: <a href="https://www.rstudio.com/">RStudio</a></p>
</div>
</div>
<div id="key-stringr-functions" class="section level2">
<h2>Key <code>stringr</code> functions</h2>
<p>In this section, we will learn the following <code>stringr</code> functions:</p>
<ul>
<li><code>str_to_upper()</code> <code>str_to_lower()</code> <code>str_to_title()</code></li>
<li><code>str_trim()</code> <code>str_squish()</code></li>
<li><code>str_c()</code></li>
<li><code>str_detect()</code></li>
<li><code>str_subset()</code></li>
<li><code>str_sub()</code></li>
</ul>
<p>Many of these <code>stringr</code> functions also have base R alternatives. Accordingly, we will also see the base R functions that are roughly equivalent to each <code>stringr</code> function. Despite the equivalent base R functions, however, using <code>stringr</code> has an advantage of having a more organized API. That is, all <code>stringr</code> functions begin with <code>str_</code> prefix. Also, their first input is almost always a string object, which facilitates the use of pipe (<code>%&gt;%</code>) operator.</p>
<p>Please note that this section is not intended to be an exhuastive documentation and description of the listed functions–or <code>stringr</code> package for that matter. For more information, please check out the reference materials listed below.</p>
</div>
<div id="convert-letter-case" class="section level2">
<h2>Convert letter case</h2>
<pre class="r"><code>str_to_upper(string, locale = &quot;en&quot;)
str_to_lower(string, locale = &quot;en&quot;)
str_to_title(string, locale = &quot;en&quot;)</code></pre>
<p>One of the most basic string operations is to change cases of the character. <code>stringr</code> offers three functions for that task: <code>str_to_upper()</code>, <code>str_to_lower()</code>, and <code>str_to_title()</code>.</p>
<p>All three functions take a character vector as the first argument input, <code>string</code>. In fact, if it is not a character vector but can be coerced into one, <code>str_to_*()</code> will automatically coerce, or convert, the input into a character vector.</p>
<p><code>str_to_upper()</code> turns all characters into uppercase letters, and <code>str_to_lower()</code>, to lowercase letters. <code>str_to_title()</code> capitalizes only the first letter of each word, seperated by a whitespace.</p>
<div id="example" class="section level3">
<h3>Example</h3>
<p>Using each of <code>stringr</code>’s case-changing functions is pretty straightforward:</p>
<pre class="r"><code>str_to_upper(&quot;hello world&quot;)</code></pre>
<pre><code>## [1] &quot;HELLO WORLD&quot;</code></pre>
<pre class="r"><code>str_to_lower(&quot;HELLO WORLD&quot;)</code></pre>
<pre><code>## [1] &quot;hello world&quot;</code></pre>
<pre class="r"><code>str_to_title(&quot;hello WORLD&quot;)</code></pre>
<pre><code>## [1] &quot;Hello World&quot;</code></pre>
</div>
<div id="base-r-alternative" class="section level3">
<h3>Base R alternative</h3>
<pre class="r"><code># equivalent to str_to_upper()
toupper(string)

# equivalent to str_to_lower()
tolower(string)</code></pre>
<p>Base R offers functions equivalent to <code>str_to_upper()</code> and <code>str_to_lower()</code>.</p>
</div>
</div>
<div id="trim-whitespace" class="section level2">
<h2>Trim whitespace</h2>
<pre class="r"><code>str_trim(string, side = c(&quot;both&quot;, &quot;left&quot;, &quot;right&quot;))
str_squish(string)</code></pre>
<p><code>str_trim()</code> and <code>str_squish()</code> are functions to trim, or remove, unwanted whitespaces in a character string. As before, the first input <code>string</code> is a character vector. The <code>side</code> argument in <code>str_trim()</code> determines which side of a string to trim: “both” trims whitespaces on both the beginning and the end, “left” trims whitespaces only on the beginning, and “right” trims whitespaces only on the end. <code>str_squish()</code> detects any execssive whitespace and removes it rom the input.</p>
<div id="example-1" class="section level3">
<h3>Example</h3>
<p>The following code example shows how trimming whitespaces work. Notice that <code>str_squish()</code> also takes care of whitespaces within the string in addition to the left and right ends.</p>
<pre class="r"><code>str_trim(&quot;  trim both  &quot;, side = &quot;both&quot;)</code></pre>
<pre><code>## [1] &quot;trim both&quot;</code></pre>
<pre class="r"><code>str_trim(&quot;  trim left only  &quot;, side = &quot;left&quot;)</code></pre>
<pre><code>## [1] &quot;trim left only  &quot;</code></pre>
<pre class="r"><code>str_trim(&quot;  trim right only  &quot;, side = &quot;right&quot;)</code></pre>
<pre><code>## [1] &quot;  trim right only&quot;</code></pre>
<pre class="r"><code>str_squish(&quot;  whitespaces all    over the  place   &quot;)</code></pre>
<pre><code>## [1] &quot;whitespaces all over the place&quot;</code></pre>
</div>
<div id="base-r-alternative-1" class="section level3">
<h3>Base R alternative</h3>
<pre class="r"><code># equivalent to str_trim()
trimws(x, which = c(&quot;both&quot;, &quot;left&quot;, &quot;right&quot;))</code></pre>
<p>Base R also offers a function to remove leading and/or trailing whitespaces.</p>
</div>
</div>
<div id="concatenate-strings-into-one" class="section level2">
<h2>Concatenate strings into one</h2>
<pre class="r"><code>str_c(..., sep = &quot;&quot;, collapse = NULL)</code></pre>
<p><code>str_c()</code> concatenates multiple strings into a single string. The first argument (<code>...</code>) is one more more character vectors for the concatenating operation. There are two ways to concatenate strings. First is an element-wise concatenation with <code>sep</code>, which a separator string between input vectors. The default value is none (<code>&quot;&quot;</code>). Second way of concatenating strings use <code>collapse</code>, an optional string used to combined input vectors into a single string.</p>
<div id="example-2" class="section level3">
<h3>Example</h3>
<p>The following examples illustrate how concatenating strings with <code>sep</code> and <code>collapse</code> works.</p>
<pre class="r"><code>str_c(c(&quot;one&quot;, &quot;two&quot;), c(&quot;plus three&quot;, &quot;minus four&quot;), sep = &quot; &quot;)</code></pre>
<pre><code>## [1] &quot;one plus three&quot; &quot;two minus four&quot;</code></pre>
<p>In the first case, we are doing element-wise concatenation between two character vectors. Here we see ethat the first element of the first vector and the first element of the second vector is concatenated with a single whitespace in between. The same thing goes for the second element of both vectors. The output is a character vector of length 2, whose elements are concatenated strings that result from the elements of the input vectors.</p>
<pre class="r"><code>str_c(c(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;), &quot;plus four&quot;, sep = &quot; &quot;)</code></pre>
<pre><code>## [1] &quot;one plus four&quot;   &quot;two plus four&quot;   &quot;three plus four&quot;</code></pre>
<p>When the length of input vectors do not match, the shorter vector is recycled. Here, the first input vector has a length of 3 while the second input vector has a length of 1. Consequently, the second vector element, <code>&quot;plus four&quot;</code> is recycled and used for concatenation for all three elements of the first input vector. The output has a lenght of 3, which matches the lenght of the longest input vector.</p>
<pre class="r"><code>str_c(c(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;), collapse = &quot; plus &quot;)</code></pre>
<pre><code>## [1] &quot;one plus two plus three&quot;</code></pre>
<p>Here we see how <code>collapse</code> works. Note that the final output is a vector of lenght 1, whose only element is a string with all elements of the input vector concatenated with the <code>collapse</code> input in between.</p>
<pre class="r"><code>str_c(c(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;), &quot;plus four&quot;, sep = &quot; &quot;, collapse = &quot; and &quot;)</code></pre>
<pre><code>## [1] &quot;one plus four and two plus four and three plus four&quot;</code></pre>
<p>Of course, we can combine <code>sep</code> and <code>collapse</code> to try a more complicated concatenation task.</p>
</div>
<div id="base-r-alternative-2" class="section level3">
<h3>Base R alternative</h3>
<pre class="r"><code># equivalent to str_c()
paste (..., sep = &quot; &quot;, collapse = NULL)</code></pre>
<p>Base R alternative to <code>str_c()</code> is <code>paste()</code>, which works pretty much the same.</p>
</div>
</div>
<div id="detect-a-pattern" class="section level2">
<h2>Detect a pattern</h2>
<pre class="r"><code>str_detect(string, pattern)</code></pre>
<p><code>str_detect()</code> is used to detect the presence/absence of a speficied pattern in the input string. As before, <code>string</code> input is a character vector. <code>pattern</code> input is a character vector of length 1 that is a pattern to look for. Finally, output is a boolean (<code>TRUE</code> or <code>FALSE</code>) vector of the same length as the <code>string</code> input.</p>
<p>Note that the <code>pattern</code> input can include regualr expressions, which will be discussed <a href="#regex">later</a> in the current note.</p>
<div id="example-3" class="section level3">
<h3>Example</h3>
<p>In this example, we have an input string of length 3. The pattern we want to detect is <code>&quot;I like&quot;</code>. As expected, the output is a boolean vecotr of length 3, whose element has a value of either <code>TRUE</code> or <code>FALSE</code> based on the presence of the pattern in the correspoding element in the input vector.</p>
<pre class="r"><code>str = c(&quot;I like apple&quot;, &quot;You like apple&quot;, &quot;Apple, I like&quot;)
pat = &quot;I like&quot;
str_detect(str, pat)</code></pre>
<pre><code>## [1]  TRUE FALSE  TRUE</code></pre>
</div>
<div id="base-r-alternative-3" class="section level3">
<h3>Base R alternative</h3>
<pre class="r"><code># equivalent to str_detect()
grepl(pattern, x, ...)</code></pre>
<p>The <code>grepl()</code> function of base R is equivalent to <code>str_detect()</code>, although the order of input argument is different: <code>pattern</code> input comes before the string input <code>x</code>.</p>
</div>
</div>
<div id="get-stringspositions-matching-a-pattern" class="section level2">
<h2>Get strings/positions matching a pattern</h2>
<pre class="r"><code>str_subset(string, pattern)
str_which(string, pattern)</code></pre>
<p><code>str_subset()</code> and <code>str_which()</code> are similar functions that take a character vector as the <code>string</code> input and a pattern to look for as the <code>pattern</code> input. As in <code>str_detect()</code>, the pattern can be speficied using regular expression.</p>
<p>The key difference between <code>str_subset()</code> and <code>str_which()</code> is that the former returns the strings that match the pattern while the latter returns the index of the matching strings.</p>
<div id="example-4" class="section level3">
<h3>Example</h3>
<p>The following example illustrates the different outputs of <code>str_subset()</code> and <code>str_which()</code>:</p>
<pre class="r"><code>str = c(&quot;I like apple&quot;, &quot;You like apple&quot;, &quot;Apple, I like&quot;)
pat = &quot;I like&quot;
str_subset(str, pat)</code></pre>
<pre><code>## [1] &quot;I like apple&quot;  &quot;Apple, I like&quot;</code></pre>
<pre class="r"><code>str_which(str, pat)</code></pre>
<pre><code>## [1] 1 3</code></pre>
</div>
<div id="base-r-alternative-4" class="section level3">
<h3>Base R alternative</h3>
<pre class="r"><code># equivalent to str_subset()
grep(pattern, x, value = TRUE, ...)

# equivalent to str_which()
grep(pattern, x, value = FALSE, ...)</code></pre>
<p>Base R offers <code>grep()</code>, which can do the work of both <code>str_subset()</code> and <code>str_which()</code>, depending on the <code>value</code> argument input.</p>
</div>
</div>
<div id="extract-and-replace-substrings" class="section level2">
<h2>Extract and replace substrings</h2>
<pre class="r"><code>str_sub(string, start = 1L, end = -1L)
str_sub(string, start = 1L, end = -1L, omit_na = FALSE) &lt;- value</code></pre>
<ul>
<li><code>string</code> input is a character vector</li>
<li><code>start</code> and <code>end</code> are integer vectors
<ul>
<li><code>start</code> is the position of the first substring character; default is the first character</li>
<li><code>end</code> is the position of the last substring character; default is the last character</li>
</ul></li>
<li>Output is a character vector of substring from <code>start</code> to <code>end</code>.</li>
<li><code>str_sub()</code> can be used to replace substrings when used with the assignment operator (<code>&lt;-</code>)</li>
</ul>
<div id="example-5" class="section level3">
<h3>Example</h3>
<p>The following example code illustate using <code>str_sub()</code> to both get and set substring value for the input:</p>
<pre class="r"><code>str &lt;- &quot;Hello world&quot;
str_sub(str, start = 7)</code></pre>
<pre><code>## [1] &quot;world&quot;</code></pre>
<pre class="r"><code>str_sub(str, end = 5) &lt;- &quot;Hi&quot;
str</code></pre>
<pre><code>## [1] &quot;Hi world&quot;</code></pre>
</div>
<div id="base-r-alternative-5" class="section level3">
<h3>Base R alternative</h3>
<pre class="r"><code># equivalent to str_sub()
substr(x, start, stop)

# equivalent to str_sub() &lt;- value
substr(x, start, stop) &lt;- value</code></pre>
<p>The base R alternative <code>str_sub()</code> is <code>substr()</code>, which can also be used to both get and set the substring value.</p>
</div>
</div>
<div id="more-on-stringr" class="section level2">
<h2>More on <code>stringr</code></h2>
<p>What we have touched upon so far is only a small (though highly useful) part of <code>stringr</code>. I recommend you to check out the following resources:</p>
<ul>
<li><code>stringr</code> on <a href="http://stringr.tidyverse.org/">tidyverse.org</a></li>
<li><code>stringr</code> <a href="https://cran.r-project.org/web/packages/stringr/stringr.pdf">CRAN documentation</a></li>
<li><code>stringr</code> <a href="https://github.com/tidyverse/stringr">Github repository</a></li>
</ul>
<hr />
</div>
</div>
<div id="regex" class="section level1">
<h1>Regular expression (regex)</h1>
<blockquote>
<p>“Regular expressions are a concise and flexible tool for describing patterns in strings.” <br>-<em>stringr.tidyverse.org</em></p>
</blockquote>
<p>Regular expression is a collection of special characters and syntax for character strings that allow us to use more complex and dynamic patterns for manipulating and working with strings. Regular expression can be a class of its own. In this section, we will briefly take a look at various elements of regular expression as used in R.</p>
<div id="regular-expression-in-r" class="section level2">
<h2>Regular expression in R</h2>
<p>In the following, we will explore the following types of regular expression in R:</p>
<ul>
<li>Character classes</li>
<li>Metacharacters</li>
<li>Groups</li>
<li>Anchors</li>
<li>Quantifiers</li>
</ul>
</div>
<div id="character-classes" class="section level2">
<h2>Character classes</h2>
<p>Character classes provide a consice way to refer to certain sets of characters, such as alphebetical letters, digits, and various types of whitespaces. The following table offers a quick summary of character classes in R:</p>
<table>
<thead>
<tr class="header">
<th align="left">Class</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>[[:digit:]]</code> or <code>\d</code></td>
<td align="left">Any digits; i.e. <code>[0-9]</code></td>
</tr>
<tr class="even">
<td align="left"><code>\\D</code></td>
<td align="left">Non-digits; i.e. <code>[^0-9]</code></td>
</tr>
<tr class="odd">
<td align="left"><code>[[:lower:]]</code></td>
<td align="left">Lower-case letters; i.e. <code>[a-z]</code></td>
</tr>
<tr class="even">
<td align="left"><code>[[:upper:]]</code></td>
<td align="left">Upper-case letters; i.e. <code>[A-Z]</code></td>
</tr>
<tr class="odd">
<td align="left"><code>[[:alpha:]]</code></td>
<td align="left">Alphabetic characters; <code>[A-z]</code></td>
</tr>
<tr class="even">
<td align="left"><code>[[:alnum:]]</code></td>
<td align="left">Alphanumeric characters; i.e. <code>[A-z0-9]</code></td>
</tr>
<tr class="odd">
<td align="left"><code>\\w</code></td>
<td align="left">Any Word characters; i.e. <code>[A-z0-9_]</code></td>
</tr>
<tr class="even">
<td align="left"><code>\\W</code></td>
<td align="left">Non-word characters</td>
</tr>
<tr class="odd">
<td align="left"><code>[[:blank:]]</code></td>
<td align="left">Space and tab</td>
</tr>
<tr class="even">
<td align="left"><code>[[:space:]]</code> or <code>\s</code></td>
<td align="left">Space, tab, vertical tab, newline, form feed, carriage return</td>
</tr>
<tr class="odd">
<td align="left"><code>\\S</code></td>
<td align="left">Not space; i.e. <code>[^[:space:]]</code></td>
</tr>
</tbody>
</table>
<div id="example-6" class="section level3">
<h3>Example</h3>
<p>The following code shows how regular expression character classes work:</p>
<pre class="r"><code>str &lt;- c(&quot;HELLO&quot;, &quot;world&quot;, &quot;123&quot;, &quot;\n&quot;)
str_detect(str, &quot;\\d&quot;) # has any digit</code></pre>
<pre><code>## [1] FALSE FALSE  TRUE FALSE</code></pre>
<pre class="r"><code>str_detect(str, &quot;\\D&quot;) # has no digit</code></pre>
<pre><code>## [1]  TRUE  TRUE FALSE  TRUE</code></pre>
<pre class="r"><code>str_detect(str, &quot;\\w&quot;) # has any alphanumetic character</code></pre>
<pre><code>## [1]  TRUE  TRUE  TRUE FALSE</code></pre>
<pre class="r"><code>str_detect(str, &quot;\\s&quot;) # has any whitespate</code></pre>
<pre><code>## [1] FALSE FALSE FALSE  TRUE</code></pre>
</div>
</div>
<div id="metacharacters" class="section level2">
<h2>Metacharacters</h2>
<p>Metacharacters are characters with special meaning to the computer program. The following table lists a selection of metacharacters and their meanings:</p>
<table>
<thead>
<tr class="header">
<th align="left">Metacharacter</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>\n</code></td>
<td align="left">New line</td>
</tr>
<tr class="even">
<td align="left"><code>\r</code></td>
<td align="left">Carriage return</td>
</tr>
<tr class="odd">
<td align="left"><code>\t</code></td>
<td align="left">Tab</td>
</tr>
<tr class="even">
<td align="left"><code>\v</code></td>
<td align="left">Vertical tab</td>
</tr>
<tr class="odd">
<td align="left"><code>\f</code></td>
<td align="left">Form feed</td>
</tr>
</tbody>
</table>
</div>
<div id="groups" class="section level2">
<h2>Groups</h2>
<p>Regular expression groups offer various ways to specify groups of characters. The following table provides a summary of groups in R:</p>
<table>
<thead>
<tr class="header">
<th align="left">Group</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>.</code></td>
<td align="left">Any character except <code>\n</code></td>
</tr>
<tr class="even">
<td align="left">|</td>
<td align="left">Or, e.g. <code>(a</code>|<code>b)</code></td>
</tr>
<tr class="odd">
<td align="left"><code>[...]</code></td>
<td align="left">List permitted characters, e.g. <code>[abc]</code></td>
</tr>
<tr class="even">
<td align="left"><code>[a-z]</code></td>
<td align="left">Specify character ranges</td>
</tr>
<tr class="odd">
<td align="left"><code>[^...]</code></td>
<td align="left">List excluded characters</td>
</tr>
<tr class="even">
<td align="left"><code>(...)</code></td>
<td align="left">Grouping, enables back referencing using <code>\\N</code> where <code>N</code> is integer</td>
</tr>
</tbody>
</table>
<div id="example-7" class="section level3">
<h3>Example</h3>
<p>The following code example is to illustrate how regular expression groups work.</p>
<pre class="r"><code>str &lt;- c(&quot;HELLO&quot;, &quot;world&quot;, &quot;123&quot;, &quot;\n&quot;)
str_detect(str, &quot;.&quot;) # has any character except \n</code></pre>
<pre><code>## [1]  TRUE  TRUE  TRUE FALSE</code></pre>
<pre class="r"><code>str_detect(str, &quot;(d|1)&quot;) # has d or 1</code></pre>
<pre><code>## [1] FALSE  TRUE  TRUE FALSE</code></pre>
<pre class="r"><code>str_detect(str, &quot;[Oo]&quot;) # has O or o</code></pre>
<pre><code>## [1]  TRUE  TRUE FALSE FALSE</code></pre>
<pre class="r"><code>str_detect(str, &quot;[^HELLO123]&quot;) # has characters other than...</code></pre>
<pre><code>## [1] FALSE  TRUE FALSE  TRUE</code></pre>
</div>
</div>
<div id="anchors" class="section level2">
<h2>Anchors</h2>
<p>Regular expression anchors make it possible to add locational information to a particular character, e.g., the beginning or end of the whole string. The following table provides a summary of anchors in R:</p>
<table>
<thead>
<tr class="header">
<th align="left">Anchor</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>^</code></td>
<td align="left">Start of the string</td>
</tr>
<tr class="even">
<td align="left"><code>$</code></td>
<td align="left">End of the string</td>
</tr>
<tr class="odd">
<td align="left"><code>\\b</code></td>
<td align="left">Empty string at either edge of a word</td>
</tr>
<tr class="even">
<td align="left"><code>\\B</code></td>
<td align="left">NOT the edge of a word</td>
</tr>
<tr class="odd">
<td align="left"><code>\\&lt;</code></td>
<td align="left">Beginning of a word</td>
</tr>
<tr class="even">
<td align="left"><code>\\&gt;</code></td>
<td align="left">End of a word</td>
</tr>
</tbody>
</table>
<div id="example-8" class="section level3">
<h3>Example</h3>
<p>The following code shows how regular expression anchors can be used:</p>
<pre class="r"><code>str &lt;- c(&quot;apple&quot;, &quot;apricot&quot;, &quot;banana&quot;, &quot;pineapple&quot;)
str_detect(str, &quot;^(a|ba)&quot;)</code></pre>
<pre><code>## [1]  TRUE  TRUE  TRUE FALSE</code></pre>
<pre class="r"><code>str_detect(str, &quot;apple$&quot;)</code></pre>
<pre><code>## [1]  TRUE FALSE FALSE  TRUE</code></pre>
</div>
</div>
<div id="quantifiers" class="section level2">
<h2>Quantifiers</h2>
<p>Quantifiers capture the pattenr of repetition for specified characters. The following table offers a summary of quantifiers in R:</p>
<table>
<thead>
<tr class="header">
<th align="left">Quantifier</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>*</code></td>
<td align="left">Matches at least 0 times</td>
</tr>
<tr class="even">
<td align="left"><code>+</code></td>
<td align="left">Matches at least 1 time</td>
</tr>
<tr class="odd">
<td align="left"><code>?</code></td>
<td align="left">Matches at most 1 time; optional string</td>
</tr>
<tr class="even">
<td align="left"><code>{n}</code></td>
<td align="left">Matches extactly <code>n</code> times</td>
</tr>
<tr class="odd">
<td align="left"><code>{n, }</code></td>
<td align="left">Matches at least <code>n</code> times</td>
</tr>
<tr class="even">
<td align="left"><code>{, n}</code></td>
<td align="left">Matches at most <code>n</code> times</td>
</tr>
<tr class="odd">
<td align="left"><code>{n, m}</code></td>
<td align="left">Matches between <code>n</code> and <code>m</code> times</td>
</tr>
</tbody>
</table>
<div id="example-9" class="section level3">
<h3>Example</h3>
<p>The example below illustrates the use of various quntifiers to specify repetition patterns:</p>
<pre class="r"><code>str &lt;- c(&quot;apple&quot;, &quot;apricot&quot;, &quot;banana&quot;, &quot;pineapple&quot;)
str_detect(str, &quot;p*&quot;)</code></pre>
<pre><code>## [1] TRUE TRUE TRUE TRUE</code></pre>
<pre class="r"><code>str_detect(str, &quot;p+&quot;)</code></pre>
<pre><code>## [1]  TRUE  TRUE FALSE  TRUE</code></pre>
<pre class="r"><code>str_detect(str, &quot;p{2,}&quot;)</code></pre>
<pre><code>## [1]  TRUE FALSE FALSE  TRUE</code></pre>
</div>
</div>
<div id="more-on-regular-expression" class="section level2">
<h2>More on regular expression</h2>
<p>As mentioned earlier, regular expression is a broad topic. To get a better hold of regular expression, I recommend you to check out the following resources:</p>
<ul>
<li><a href="https://www.regular-expressions.info/rlanguage.html">Regular-Expressions.info</a></li>
<li>RStudio. (2016).<a href="https://www.rstudio.com/wp-content/uploads/2016/09/RegExCheatsheet.pdf">“Basic Regular Expressions in R: Cheat Sheet”.</a></li>
<li>Tidyverse. (n.d.). <a href="http://stringr.tidyverse.org/articles/regular-expressions.html">“Regualr Expressions”</a>. <em>stringr.tidyverse.org</em>.</li>
</ul>
<hr />
</div>
</div>
<div id="working-with-datetimes" class="section level1">
<h1>Working with Datetimes</h1>
<img src="../images/calendar.png" width="30%" style="box-shadow: none; display: block; margin: auto;" />
<div style="font-size:0.5em; text-align:center; color: #777;">
<p>Source: <a href="https://cdn4.iconfinder.com/data/icons/small-n-flat/24/calendar-512.png">Iconfinder.com</a></p>
</div>
<p>The work of data analysis often deals with dates. R has data types for date and datetime, which come with useful properties for understanding and analyzing temporal characteristics of data.</p>
<div id="datesdatetimes-basics" class="section level2">
<h2>Dates/Datetimes basics</h2>
<p>As just mentioned, R offers roughly two data types for date and datetime. First, <code>Date</code> is a class that represents calendar dates, which is represented as the number of days since 1970-01-01. Second, <code>POSIXct</code> and <code>POSIXlt</code> are two classes for representing calendar dates and times. Technically, the <code>POSIXct</code> class represents the specified datetime as a number of seconds since 1970-01-01, and <code>POSIXlt</code> represents it in a mixed text and character format. In practice, however, these two prints the identical value and can be used almost interchangeably.</p>
<p><code>Date</code> and <code>POSIX*</code> classes have useful properties for working with date and datetime, one of which is the possibility of breaking down the data into the time components.</p>
</div>
<div id="lubridate-from-tidyverse" class="section level2">
<h2><code>lubridate</code> from tidyverse</h2>
type:section <img src="../images/lubridate.png" width="25%" style="box-shadow: none; display: block; margin: auto;" />
<div style="font-size:0.5em; text-align:center; color: #777;">
<p>Source: <a href="https://www.rstudio.com/">RStudio</a></p>
</div>
</div>
<div id="key-lubridate-functions" class="section level2">
<h2>Key <code>lubridate</code> functions</h2>
<p>In this section, we will learn the following <code>lubridate</code> functions: * <code>as_date()</code> <code>as_datetime()</code> * <code>year()</code>, <code>month()</code>, <code>day()</code>, <code>hour()</code>, … * <code>parse_date_time()</code> <code>fast_strptime()</code> * <code>ymd_hms()</code>, <code>ymd()</code>, …</p>
<p>As in <code>stringr</code>, many of <code>lubridate</code> functions have base R alternatives, which we will see whenever relevant. Again, the benefit of using <code>lubridate</code> functions is the cleaner API in addition to some extra convenience.</p>
</div>
<div id="convert-to-a-date-or-date-time" class="section level2">
<h2>Convert to a date or date-time</h2>
<pre class="r"><code>as_date(x, tz = NULL, origin = lubridate::origin)
as_datetime(x, tz = NULL, origin = lubridate::origin)</code></pre>
<p><code>as_date()</code> and <code>as_datetime()</code> take a vector of POSIXt, numeric or character objects as the input for the first argument, <code>x</code>, and returns a date/datetime object. <code>tz</code> input is a time zone name, such as <code>&quot;CST&quot;</code>. Finally, <code>origin</code> is a Date object or something that can be coerced into a Date object, with the default value of <code>&quot;1970-01-01&quot;</code>.</p>
<p>The difference between <code>as_date()</code> and <code>as_datetime()</code> is that the former results in a <code>Date</code> objet while the latter returns a <code>POSIXct</code> object.</p>
<div id="example-10" class="section level3">
<h3>Example</h3>
<p>Let’s take a quick look at how <code>as_date()</code> and <code>as_datetime()</code> works. Note that the input for these functions can be in varying forms, including a numeric value.</p>
<pre class="r"><code>as_date(17618)</code></pre>
<pre><code>## [1] &quot;2018-03-28&quot;</code></pre>
<pre class="r"><code>class(as_date(&quot;20180328&quot;))</code></pre>
<pre><code>## [1] &quot;Date&quot;</code></pre>
<pre class="r"><code>as_datetime(&quot;2018/03/28&quot;)</code></pre>
<pre><code>## [1] &quot;2018-03-28 UTC&quot;</code></pre>
<pre class="r"><code>class(as_datetime(&quot;2018-03-28&quot;))</code></pre>
<pre><code>## [1] &quot;POSIXct&quot; &quot;POSIXt&quot;</code></pre>
</div>
<div id="base-r-alternative-6" class="section level3">
<h3>Base R alternative</h3>
<pre class="r"><code># equivalent to as_date()
as.Date(x, ...)

# equivalent to as_datetime()
as.POSIXct(x, tz = &quot;&quot;, ...)</code></pre>
<p>Base R offers <code>as.Date()</code>, which corresponds to <code>as_date()</code>, and <code>as.POSIXct()</code>, which is equivalent to <code>as_datetime()</code>.</p>
</div>
</div>
<div id="getset-time-component" class="section level2">
<h2>Get/set time component</h2>
<pre class="r"><code>year(x)
year(x) &lt;- value</code></pre>
<p><code>lubridate</code> offers a set of functiosn to easily get and set time component of a date/datetime object. The first input, <code>x</code>, is a date/datetime object. When used with the assignment operator, <code>&lt;-</code>, we can give a new value to the specified component of the input object.</p>
<p>The following table provides a list of selected functions for getting/setting time component:</p>
<table>
<thead>
<tr class="header">
<th align="left">Function</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>year()</code></td>
<td align="left">Get/set year component of a date-time</td>
</tr>
<tr class="even">
<td align="left"><code>month()</code></td>
<td align="left">Get/set months component of a date-time</td>
</tr>
<tr class="odd">
<td align="left"><code>week()</code></td>
<td align="left">Get/set weeks component of a date-time</td>
</tr>
<tr class="even">
<td align="left"><code>day()</code></td>
<td align="left">Get/set days component of a date-time</td>
</tr>
<tr class="odd">
<td align="left"><code>hour()</code></td>
<td align="left">Get/set hours component of a date-time</td>
</tr>
<tr class="even">
<td align="left"><code>minute()</code></td>
<td align="left">Get/set minutes component of a date-time</td>
</tr>
<tr class="odd">
<td align="left"><code>second()</code></td>
<td align="left">Get/set seconds component of a date-time</td>
</tr>
<tr class="even">
<td align="left"><code>tz()</code></td>
<td align="left">Get/set time zone component of a date-time</td>
</tr>
</tbody>
</table>
<div id="example-11" class="section level3">
<h3>Example</h3>
<p>The following example illustrates how to get/set time components of a date object:</p>
<pre class="r"><code>today &lt;- as_date(&quot;2018-03-28&quot;)
year(today)</code></pre>
<pre><code>## [1] 2018</code></pre>
<pre class="r"><code>month(today) &lt;- 4
today</code></pre>
<pre><code>## [1] &quot;2018-04-28&quot;</code></pre>
</div>
</div>
<div id="parse-date-time" class="section level2">
<h2>Parse date-time</h2>
<pre class="r"><code>parse_date_time(x, orders, tz = &quot;UTC&quot;, truncated = 0, locale = Sys.getlocale(&quot;LC_TIME&quot;), exact = FALSE, drop = FALSE, ...)
fast_strptime(x, format, tz = &quot;UTC&quot;, lt = TRUE, cutoff_2000 = 68L)</code></pre>
<p>In most cases, <code>as_date()</code> and <code>as_datetime()</code> may be sufficient to convert non-date/-datetime objects to date/datetime objects. However, sometimes a more flexible approach is needed to handle a variety of input formats. <code>parse_date_time()</code> and <code>fast_strptime()</code> are functions for just that.</p>
<p>Both <code>parse_date_time()</code> and <code>fast_strptime()</code> take a character or numeric vector of dates as the input for the first argument.</p>
<p><code>parse_date_time()</code> then takes a character vector of datetime order format as <code>orders</code> input. For example, we can use <code>&quot;ymd&quot;</code> for various year-month-date formats. <code>exact</code> is a boolean value for using the “exact” match for the datetime format specificed by <code>orders</code>, and <code>drop</code> is a boolean value for dropping, or removing the values not matching the format. In</p>
<p>On the other hand, <code>fast_strptime()</code> takes a character string of formats as <code>format</code> input. The datetime format uses special symbols such as those listed in the following table:</p>
<div id="date-format-symbols" class="section level3">
<h3>Date format symbols</h3>
<table>
<thead>
<tr class="header">
<th align="left">Symbol</th>
<th align="left">Description</th>
<th align="left">Example</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">%Y</td>
<td align="left">Year in 4 digits</td>
<td align="left">2018</td>
</tr>
<tr class="even">
<td align="left">%y</td>
<td align="left">Year in 2 digits</td>
<td align="left">18</td>
</tr>
<tr class="odd">
<td align="left">%B</td>
<td align="left">Month in words</td>
<td align="left">March</td>
</tr>
<tr class="even">
<td align="left">%b</td>
<td align="left">Month in words, abbriviated</td>
<td align="left">Mar</td>
</tr>
<tr class="odd">
<td align="left">%m</td>
<td align="left">Month in 2 digits</td>
<td align="left">03</td>
</tr>
<tr class="even">
<td align="left">d</td>
<td align="left">Date in 2 digits</td>
<td align="left">28</td>
</tr>
</tbody>
</table>
</div>
<div id="example-12" class="section level3">
<h3>Example</h3>
<p>Let us take a look at some examples of “parsing” datetimes using <code>parse_date_time()</code> and <code>fast_strptime()</code>. First we have a vector of three date strings as a sample input.</p>
<pre class="r"><code>dates = c(&quot;2018-03-28&quot;, &quot;2018/03/28&quot;, &quot;20180328&quot;)</code></pre>
<p>As shown below, <code>parse_date_time()</code> is capable of taking care of varying date formats as long as the order remains the same:</p>
<pre class="r"><code>parse_date_time(dates, &quot;ymd&quot;)</code></pre>
<pre><code>## [1] &quot;2018-03-28 UTC&quot; &quot;2018-03-28 UTC&quot; &quot;2018-03-28 UTC&quot;</code></pre>
<p>In constrast, <code>fast_strptime()</code> has to specify the foramt for each input:</p>
<pre class="r"><code>fast_strptime(dates[1], &quot;%Y-%m-%d&quot;)</code></pre>
<pre><code>## [1] &quot;2018-03-28 UTC&quot;</code></pre>
<pre class="r"><code>fast_strptime(dates[2], &quot;%Y/%m/%d&quot;)</code></pre>
<pre><code>## [1] &quot;2018-03-28 UTC&quot;</code></pre>
<pre class="r"><code>fast_strptime(dates[3], &quot;%Y%m%d&quot;)</code></pre>
<pre><code>## [1] &quot;2018-03-28 UTC&quot;</code></pre>
</div>
<div id="base-r-alternative-7" class="section level3">
<h3>Base R alternative</h3>
<pre class="r"><code># equivalent to fast_strptime()
strptime(x, format = &quot;&quot;, tz = &quot;&quot;)</code></pre>
<p>Base R offers <code>strptime()</code>, which is equivalent to <code>fast_strptime()</code>. On the other hand, there is no base R alternative for <code>parse_date_time()</code>. That said, being able to handle multiple date/datetime formats with the same order is one of the advantages of using <code>parse_date_time()</code>.</p>
</div>
</div>
<div id="quickly-parse-date-time" class="section level2">
<h2>Quickly parse date-time</h2>
<pre class="r"><code>ymd_hms(..., quiet = FALSE, tz = NULL, ...)
ymd(..., quiet = FALSE, tz = &quot;UTC&quot;, ...)</code></pre>
<p><code>lubridate</code> also offers functions for quickly parse datetimes with a predefined order; under the hood, all these functions do the same work as <code>parse_date_time()</code>.</p>
<p>The first <code>...</code> argument is a character vector of dates in appropriate format. <code>quiet</code> is a boolean value for displaying messages, and <code>tz</code> is a character string speficiying time zone.</p>
<p>The following table lists a selection of functions to quickly parse datetimes.</p>
<table>
<thead>
<tr class="header">
<th align="left">Date-time</th>
<th align="left">Date only</th>
<th align="left">Time only</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>ymd_hms()</code></td>
<td align="left"><code>ymd()</code></td>
<td align="left"><code>hms()</code></td>
</tr>
<tr class="even">
<td align="left"><code>ymd_hm()</code></td>
<td align="left"><code>ydm()</code></td>
<td align="left"><code>hm()</code></td>
</tr>
<tr class="odd">
<td align="left"><code>ymd_h()</code></td>
<td align="left"><code>mdy()</code></td>
<td align="left"><code>ms()</code></td>
</tr>
<tr class="even">
<td align="left"><code>mdy_hms()</code></td>
<td align="left"><code>myd()</code></td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left"><code>mdy_hm()</code></td>
<td align="left"><code>dmy()</code></td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left"><code>mdy_h()</code></td>
<td align="left"><code>dym()</code></td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left"><code>dmy_hms()</code></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left"><code>dmy_hm()</code></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left"><code>dmy_h()</code></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody>
</table>
<ul>
<li><code>y</code> is year</li>
<li>first <code>m</code> is month</li>
<li><code>d</code> is date</li>
<li><code>h</code> is hour</li>
<li>second <code>m</code> is minute</li>
<li><code>s</code> is second</li>
</ul>
</div>
<div id="more-on-lubridate" class="section level2">
<h2>More on lubridate</h2>
<p>As in the case of <code>stringr</code>, what we have seen is only part of what <code>lubridate</code> offers. I recommend you to check out the following resources to learn more about <code>lubridate</code>.</p>
<ul>
<li><code>lubridate</code> on <a href="http://lubridate.tidyverse.org/">tidyverse.org</a></li>
<li><code>lubridate</code> <a href="https://cran.r-project.org/web/packages/lubridate/lubridate.pdf">CRAN documentation</a></li>
<li><code>lubridate</code> <a href="https://github.com/tidyverse/lubridate">Github repository</a></li>
</ul>
<hr />
</div>
</div>
<div id="importingexporting-data" class="section level1">
<h1>Importing/Exporting Data</h1>
<img src="../images/data_transfer.png" width="30%" style="box-shadow: none; display: block; margin: auto;" />
<p style="font-size:0.5em; text-align:center; color: #777;">
Source: <a href="https://www.wikimedia.org">Wikimedia Commons</a>
</p>
<p>Importing and exporting datasets in different formats is one of the basic operations for any data analysis task. Here we will explore some options for this task with datasets in various file formats.</p>
<div id="comma-separated-values-.csv" class="section level2">
<h2>Comma-separated values (.csv)</h2>
<p>Comma-separate values, with a .csv extension, is one of the most common format to store data. R ecosystem offers a few options to import/export .csv files. Here we will take a quick look at two pacakges as well as the base R solution for this task.</p>
<p>As for third-party packages, <code>tidyverse</code> offers <code>readr</code> pacakge, which has <code>read_csv()</code> and <code>write_csv()</code> functions. <code>data.table</code> package also provides functions to import and export .csv files: <code>fread()</code> and <code>write()</code>.</p>
<div id="using-readr" class="section level3">
<h3>Using <code>readr</code></h3>
<pre class="r"><code>read_csv(file, col_names = TRUE, col_types = NULL, na = c(&quot;&quot;, &quot;NA&quot;), trim_ws = TRUE, skip = 0, n_max = Inf, guess_max = min(1000, n_max), ...)
write_csv(x, path, na = &quot;NA&quot;, append = FALSE, col_names = !append)</code></pre>
<p>In <code>read_csv()</code>, <code>file</code> is a path to a .csv file to import. <code>col_names</code> is a boolean value for using the first row values as column names. <code>na</code> input defines what values to consider missing values. <code>skip</code> input is a number of rows to skip before what is going to be the first row for the output data object. The output is a <code>tibble</code> object.</p>
<p>In <code>write_csv()</code>, <code>x</code> is a data object to export as a .csv file, and <code>path</code> is a path to the directory where the exported data will be created. <code>append</code> is a boolean value for “appending” to the existing data with the same name (path).</p>
<p>For more on the function arguments, refer to the relevant documentations.</p>
</div>
<div id="using-data.table" class="section level3">
<h3>Using <code>data.table</code></h3>
<pre class="r"><code>fread(input, sep=&quot;auto&quot;, sep2=&quot;auto&quot;, nrows=-1L, header=&quot;auto&quot;, na.strings=&quot;NA&quot;, stringsAsFactors=FALSE, skip=0L, colClasses=NULL, col.names,
strip.white=TRUE, fill=FALSE, ...)
fwrite(x, file = &quot;&quot;, append = FALSE, quote = &quot;auto&quot;, sep = &quot;,&quot;, na = &quot;&quot;, row.names = FALSE, col.names = TRUE, ...)</code></pre>
<p>In <code>fread()</code>, <code>input</code> is a path to the .csv file to import. The output of is a <code>data.table</code> object. <code>sep</code> input specifies the inter-column separator while <code>sep2</code> input defines the intra-column separator. <code>nrows</code> is the number of rows to import, where the default value is all rows. <code>header</code> input determines whether to use the first row as the “header”, i.e. column names. <code>stringAsFactors</code> value specifies whether to convert character columns into factor columns.</p>
<p>In <code>fwrite()</code>, <code>x</code> is a data object to export, and <code>file</code> is a path to the directory where the exported data will be created. <code>sep</code> input is the inter-column separator, with “,” as the default. With this default option, the output file is a .csv file in a directory.</p>
<p>For more on the function arguments, refer to the relevant documentations.</p>
<p>It is noteworthy that <code>fread</code> and <code>fwrite</code> among of the fastest options to import and export data files. Therefore, using the <code>data.table</code> functions may be a preferable solution when dealing with large datasets (e.g., hundreds of megabytes, or even gigabytes).</p>
</div>
<div id="base-r-alternative-8" class="section level3">
<h3>Base R alternative</h3>
<pre class="r"><code>read.csv(file,  header = TRUE, sep = &quot;,&quot;, quote = &quot;\&quot;&quot;, dec = &quot;.&quot;, fill = TRUE, ...)
write.csv(x, file = &quot;&quot;, append = FALSE, quote = TRUE, sep = &quot;,&quot;, row.names = TRUE, col.names = TRUE, ...)</code></pre>
<p>Base R offers functions to import and export .csv files. The arguments are similar to those used in <code>readr</code> and <code>data.table</code> functions.</p>
</div>
</div>
<div id="excel-spreadsheets-.xlsx.xls" class="section level2">
<h2>Excel spreadsheets (.xlsx/.xls)</h2>
<p>An Excel spreadsheet is another common way to store a tabular data. While base R offers no functiosn to import and export Excel files (.xlsx or .xls), <code>tidyverse</code> has <code>readxl</code> package for this functionality.</p>
<pre class="r"><code>read_excel(path, sheet = NULL, range = NULL, col_names = TRUE, col_types = NULL, na = &quot;&quot;, trim_ws = TRUE, skip = 0, n_max = Inf, guess_max = min(1000, n_max))
read_xls(path, ...)
read_xlsx(path, ...)</code></pre>
<p>In <code>read_excel()</code>, <code>path</code> is a path to an Excel file (.xls or .xlsx) to import, and <code>sheet</code> is the name of a sheet in the excel file to import. If <code>sheet</code> is NULL, the default is the first sheet. <code>range</code> input can take a string of Excel ranges, such as “B3:D87”, to import. This can be used with a specified sheet, such as in <code>&quot;sheet2!B2:D78&quot;</code>, in which case any <code>sheet</code> input will be ignored. <code>col_names</code> is a boolean value for using the first row to import as column, and <code>skip</code> is a number of rows to skip. <code>guess_max</code> is a number of rows to use to guess the class of each column. Finally, the output is a <code>tibble</code> object.</p>
<p><code>read_xls</code> and <code>read_xlsx</code> is shortcuts for importing Excel files with the correponding extension. When using these functions, the <code>path</code> input can omit the extension.</p>
<p>For more on the function arguments, refer to the relevant documentations.</p>
<div id="more-on-readxl" class="section level3">
<h3>More on <code>readxl</code></h3>
<ul>
<li><code>readxl</code> on <a href="http://readxl.tidyverse.org/">tidyverse.org</a></li>
<li><code>readxl</code> <a href="https://cran.r-project.org/web/packages/readxl/readxl.pdf">CRAN documentation</a></li>
<li><code>readxl</code> <a href="https://github.com/tidyverse/readxl">Github repository</a></li>
</ul>
</div>
</div>
<div id="spss-data-files-.sav" class="section level2">
<h2>SPSS data files (.sav)</h2>
<p>SPSS is a popular commercial software for statistical analysis, and has its own data format (.sav). <code>haven</code> package of <code>tidyverse</code> offers functiosn to import and export SPSS data files.</p>
<p>Please note that <code>haven</code> also has functions to import/export the file formats of other statistical softwares, such as STATA and SAS.</p>
<pre class="r"><code>read_sav(file, user_na = FALSE)
read_spss(file, user_na = FALSE)
write_sav(data, path)</code></pre>
<p>In <code>read_sav()</code>, <code>file</code> is a path to the SPSS file (.sav) to import. <code>read_spss()</code> is a simple alias for <code>read_sav()</code>. In other case, the output is a <code>tibble</code> object.</p>
<p>In <code>write_sav()</code>, <code>file</code> is a path to export the data in <code>write_sav()</code>, and <code>data</code> is a data object to export. The output of <code>write_sav()</code> is an SPSS data file.</p>
<div id="more-on-haven" class="section level3">
<h3>More on <code>haven</code></h3>
<ul>
<li><code>haven</code> on <a href="http://haven.tidyverse.org/">tidyverse.org</a></li>
<li><code>haven</code> <a href="https://cran.r-project.org/web/packages/haven/haven.pdf">CRAN documentation</a></li>
<li><code>haven</code> <a href="https://github.com/tidyverse/haven">Github repository</a></li>
</ul>
</div>
</div>
<div id="a-fast-on-disk-data-frame-storage-.feather" class="section level2">
<h2>A “fast-on-disk” data frame storage (.feather)</h2>
<p><code>feather</code> package is developed by Hadley Wickham, one of the key contributors and authors of many <code>tidyverse</code> packages, and Wes McKinney, the author of <em>Python for Data Analysis</em> and a creator of the popular data-wrangling package for Python called <code>pandas</code>. The package offers a new file format (.feather) that can be used across R and Python, two most popular languages for data analysis and data science. <code>feather</code> is also known for fast importing and exporting of files.</p>
<pre class="r"><code>read_feather(path, columns = NULL)
write_feather(x, path)</code></pre>
<p>In <code>read_feather()</code>, <code>path</code> is a path to the .feather file to import. The output of <code>read_feather()</code> is a <code>tibble</code> object.</p>
<p>In <code>write_feather()</code>, <code>path</code> is a path to export the data in <code>write_feather()</code>, and <code>x</code> is the data object to export. The output of <code>write_feather()</code> is a .feather file.</p>
<div id="more-on-feather" class="section level3">
<h3>More on <code>feather</code></h3>
<ul>
<li>Wickham, H. (2016), <a href="https://blog.rstudio.com/2016/03/29/feather/">“Feather: A Fast On-Disk Format for Data Frames for R and Python, powered by Apache Arrow”</a>. <em>RStudio Blog</em>.</li>
<li><code>feather</code> <a href="https://cran.r-project.org/web/packages/haven/haven.pdf">CRAN documentation</a></li>
</ul>
<hr />
</div>
</div>
</div>
<div id="references" class="section level1">
<h1>References</h1>
<ul>
<li>
Grolemund, G. &amp; Wickham, H. (2017). <a href="http://r4ds.had.co.nz/"><span style="font-style:italic">R for Data Science</span></a>.
</li>
<li>
Kabacoff, R. (2017). <a href="https://www.statmethods.net/input/dates.html">“Date Values”</a>. <span style="font-syle:italic">Quick-R</span>.
</li>
<li>
RStudio. (2017). <a href="https://www.rstudio.com/resources/cheatsheets/">“Dates and Times Cheat Sheet”</a>.
</li>
<li>
RStudio. (2017). <a href="https://www.rstudio.com/resources/cheatsheets/">“Work with Strings Cheat Sheet”</a>.
</li>
<li>
Tidyverse. (n.d.). <a href="http://haven.tidyverse.org/index.html"><span style="font-style:italic">haven.tidyverse.org</span></a>
</li>
<li>
Tidyverse. (n.d.). <a href="http://lubridate.tidyverse.org/index.html"><span style="font-style:italic">lubridate.tidyverse.org</span></a>
</li>
<li>
Tidyverse. (n.d.). <a href="http://readr.tidyverse.org/index.html"><span style="font-style:italic">readr.tidyverse.org</span></a>
</li>
<li>
Tidyverse. (n.d.). <a href="http://readxl.tidyverse.org/index.html"><span style="font-style:italic">readxl.tidyverse.org</span></a>
</li>
<li>
Tidyverse. (n.d.). <a href="http://stringr.tidyverse.org/index.html"><span style="font-style:italic">stringr.tidyverse.org</span></a>
</li>
</ul>
</div>

<footer>
  <p>Copyright &copy; 2018 Bobae Kang. All rights reserved.</p>
  <a href="https://github.com/bobaekang/" class="icon-footer">
    <i class="fa fa-github fa-2x"></i>
  </a>
  <a href="https://www.linkedin.com/in/bobaekang/" class="icon-footer">
    <i class="fa fa-linkedin-square fa-2x"></i>
  </a>
</footer>


</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
